# Artifaqt contracts

## Local development

### First setup
```shell
$ npm i
```

Locally installs npm packages needed for development


### Start local ethereum server
```shell
$ npm run dev
```

Starts a `ganache` docker container with a fixed seed on port `7545`.

### Run tests
```shell
$ npm run test
```

It will run all tests. It needs to have a running local ethereum server on port `7545`

### Stop local ethereum server
```shell
$ npm run dev-stop
```

It kills and removes the `ganache` docker container.

## Contribuition guide

- Create pull requests or merge requests, do not push directly to master.
- Make sure tests work before creating request.

## Claiming tokens

In order to claim tokens, the `player` needs to make a call to `claimToken()`.

The definition of `claimToken()` is

```solidity
function claimToken(bytes32 _msgHash, uint8 _v, bytes32 _r, bytes32 _s, bytes32 _sin)
```

- `_signature` - `_sin` message signed by player.
- `_v`, `_r`, `_s` - values from the signature; enable signature checking
- `_sin` - payload that was signed by the player.

### Constructing the `_sin` payload

In order to have a different payload for each player for each station, a unique payload needs to be constructed. I wanted to deter people from watching transactions happening on the chain and just replicating what others are doing.

#### Version 1
Consider the simple, most exploitable version:

- `player` scans QR code
- The `message` behind the QR code is signed by the `player`
- Generated `signature` (along with `v`, `r`, `s`) and the `message` (hashed or not) are sent in a transaction
- The Artifaqt contract can verify the `signature` came from the `player` and the `message` matches a sin (ex: `message` is "Limbo")

The problem with this approach is that anybody watching the artifaqt contract can send transactions with the same `message` and a valid `signature` created by himself and receive the token.

#### Version 2
A better approach is to salt the signed message with the `player`'s address before hashing.

- `player` scans QR code
- The `message` behind the QR code is hashed and concatenated with the `player`'s address. The result is hashed once again, representing the `payload`
- Generated `signature` (along with `v`, `r`, `s`) and the `payload` are sent in a transaction
- The Artifaqt contract verifies 3 things:
    - `signature` was generated by `msg.sender`
    - `message` + `player` address equal the `payload`